<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaboration Space | f: H √ó A ‚Üí ùíú</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: #0a0a0f;
            color: #e8e8f0;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }
        
        .overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }
        
        .header {
            top: 2rem;
            left: 2rem;
        }
        
        .header h1 {
            font-size: 1.5rem;
            font-weight: 400;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        
        .header .subtitle {
            color: #888899;
            font-size: 0.85rem;
        }
        
        .legend {
            bottom: 6rem;
            left: 2rem;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid #2a2a3a;
            border-radius: 8px;
            padding: 1.5rem;
            pointer-events: auto;
        }
        
        .legend h3 {
            font-size: 0.8rem;
            font-weight: 500;
            color: #6699ff;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.6rem;
            font-size: 0.75rem;
            color: #888899;
        }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .legend-line {
            width: 20px;
            height: 2px;
        }
        
        .controls {
            bottom: 6rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            pointer-events: auto;
        }
        
        .controls button {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid #2a2a3a;
            border-radius: 6px;
            color: #e8e8f0;
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.6rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .controls button:hover {
            border-color: #6699ff;
            color: #6699ff;
        }
        
        .controls button.active {
            background: #6699ff;
            color: #0a0a0f;
            border-color: #6699ff;
        }
        
        .info-panel {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 100;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid #2a2a3a;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 300px;
            display: none;
            pointer-events: auto;
        }
        
        .info-panel.visible { display: block; }
        
        .info-panel h3 {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
        }
        
        .info-panel p {
            font-size: 0.75rem;
            color: #888899;
            line-height: 1.6;
            margin-bottom: 0.5rem;
        }
        
        .info-panel .fiber-count {
            color: #66ff99;
            font-size: 1.2rem;
            margin: 0.5rem 0;
        }
        
        .info-panel .close {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            color: #888899;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .info-panel .play-sound {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid #66ff99;
            color: #66ff99;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        
        .info-panel .play-sound:hover {
            background: #66ff99;
            color: #0a0a0f;
        }
        
        .back-link {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 100;
            color: #888899;
            text-decoration: none;
            font-size: 0.8rem;
        }
        
        .back-link:hover { color: #6699ff; }
        
        /* Timeline slider */
        .timeline {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            max-width: 600px;
            z-index: 100;
            pointer-events: auto;
        }
        
        .timeline-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #555566;
            margin-bottom: 0.5rem;
        }
        
        .timeline input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }
        
        .timeline input[type="range"]::-webkit-slider-track {
            height: 4px;
            background: #2a2a3a;
            border-radius: 2px;
        }
        
        .timeline input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ffcc66;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(255, 204, 102, 0.5);
        }
        
        .timeline-moment {
            text-align: center;
            font-size: 0.75rem;
            color: #ffcc66;
            margin-top: 0.5rem;
            min-height: 1.5em;
            font-style: italic;
        }
        
        .instructions {
            position: fixed;
            top: 5rem;
            left: 2rem;
            font-size: 0.65rem;
            color: #444455;
            z-index: 50;
        }
        
        /* Mapping sliders */
        .mapping-sliders {
            position: fixed;
            bottom: 6rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid #2a2a3a;
            border-radius: 8px;
            padding: 1rem 1.5rem;
            display: flex;
            gap: 1.5rem;
            pointer-events: auto;
        }
        
        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.4rem;
            min-width: 70px;
        }
        
        .slider-group label {
            font-size: 0.65rem;
            color: #888899;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .slider-group label.human { color: #ff6699; }
        .slider-group label.ai { color: #6699ff; }
        .slider-group label.artifact { color: #66ff99; }
        .slider-group label.fiber { color: #ffcc66; }
        
        .slider-group input[type="range"] {
            width: 60px;
            height: 80px;
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #e8e8f0;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-group input[type="range"]::-webkit-slider-runnable-track {
            width: 6px;
            background: #2a2a3a;
            border-radius: 3px;
        }
        
        .slider-value {
            font-size: 0.7rem;
            color: #e8e8f0;
            font-weight: 500;
        }
        
        .slider-section-label {
            font-size: 0.6rem;
            color: #555566;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            padding-right: 0.5rem;
            border-right: 1px solid #2a2a3a;
        }
        
        .mapping-section {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .sliders-row {
            display: flex;
            gap: 1.5rem;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="overlay header">
        <h1>collaboration space</h1>
        <p class="subtitle">f: Human √ó AI ‚Üí Artifact</p>
    </div>
    
    <a href="index.html" class="back-link">‚Üê back</a>
    
    <div class="overlay legend">
        <h3>THE MAPPING</h3>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ff6699;"></div>
            <span>Human input (H)</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #6699ff;"></div>
            <span>AI input (A)</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #66ff99;"></div>
            <span>Artifact (ùíú)</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: linear-gradient(90deg, #ff6699, #66ff99);"></div>
            <span>Fiber (path to artifact)</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ffcc66; box-shadow: 0 0 10px #ffcc66;"></div>
            <span>This collaboration</span>
        </div>
    </div>
    
    <div class="overlay controls">
        <button id="btn-rotate" class="active">auto-rotate</button>
        <button id="btn-fibers">show all fibers</button>
        <button id="btn-sound">‚ô™ sound the path</button>
        <button id="btn-reset">reset view</button>
        <button id="btn-reset-sim">reset sim</button>
    </div>
    
    <div class="info-panel" id="info-panel">
        <button class="close" id="close-info">√ó</button>
        <h3 id="info-title">Artifact</h3>
        <p id="info-desc">Description</p>
        <div class="fiber-count" id="info-fiber"></div>
        <p id="info-fiber-desc"></p>
        <button class="play-sound" id="play-fiber-sound">‚ô™ play this fiber</button>
    </div>
    
    <div class="mapping-sliders">
        <div class="mapping-section">
            <span class="slider-section-label">INTENSITY</span>
            <div class="sliders-row">
                <div class="slider-group">
                    <label class="human">Human</label>
                    <input type="range" id="slider-human" min="0" max="100" value="100" orient="vertical">
                    <span class="slider-value" id="val-human">100%</span>
                </div>
                <div class="slider-group">
                    <label class="ai">AI</label>
                    <input type="range" id="slider-ai" min="0" max="100" value="100" orient="vertical">
                    <span class="slider-value" id="val-ai">100%</span>
                </div>
                <div class="slider-group">
                    <label class="artifact">Artifact</label>
                    <input type="range" id="slider-artifact" min="0" max="100" value="100" orient="vertical">
                    <span class="slider-value" id="val-artifact">100%</span>
                </div>
                <div class="slider-group">
                    <label class="fiber">Fiber</label>
                    <input type="range" id="slider-fiber" min="0" max="100" value="100" orient="vertical">
                    <span class="slider-value" id="val-fiber">100%</span>
                </div>
            </div>
        </div>
        <div class="mapping-section">
            <span class="slider-section-label">COUNT</span>
            <div class="sliders-row">
                <div class="slider-group">
                    <label class="human">Human</label>
                    <input type="range" id="count-human" min="1" max="30" value="12" orient="vertical">
                    <span class="slider-value" id="count-val-human">12</span>
                </div>
                <div class="slider-group">
                    <label class="ai">AI</label>
                    <input type="range" id="count-ai" min="1" max="30" value="12" orient="vertical">
                    <span class="slider-value" id="count-val-ai">12</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="timeline">
        <div class="timeline-label">
            <span>start</span>
            <span id="time-display">moment 0</span>
            <span>now</span>
        </div>
        <input type="range" id="timeline-slider" min="0" max="100" value="100">
        <div class="timeline-moment" id="timeline-moment"></div>
    </div>
    
    <p class="instructions">drag to rotate ¬∑ scroll to zoom ¬∑ click artifacts ¬∑ slide timeline ¬∑ adjust mapping</p>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // ============ AUDIO CONTEXT ============
        let audioContext = null;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }
        
        function playNote(frequency, duration, pan = 0, delay = 0) {
            const ctx = initAudio();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const panner = ctx.createStereoPanner();
            
            osc.type = 'sine';
            osc.frequency.value = frequency;
            
            gain.gain.setValueAtTime(0, ctx.currentTime + delay);
            gain.gain.linearRampToValueAtTime(0.15, ctx.currentTime + delay + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + duration);
            
            panner.pan.value = pan;
            
            osc.connect(gain);
            gain.connect(panner);
            panner.connect(ctx.destination);
            
            osc.start(ctx.currentTime + delay);
            osc.stop(ctx.currentTime + delay + duration);
        }
        
        function positionToNote(pos) {
            // Map position to musical notes
            // X (human) -> base note (C3 to C5)
            // Y (artifact height) -> octave shift
            // Z (AI) -> chord character
            
            const baseFreq = 130.81; // C3
            const xNorm = (pos.x + 25) / 50; // 0-1
            const yNorm = (pos.y + 10) / 35; // 0-1
            const zNorm = (pos.z + 25) / 50; // 0-1
            
            // Pentatonic scale intervals
            const pentatonic = [0, 2, 4, 7, 9, 12, 14, 16, 19, 21];
            const noteIndex = Math.floor(xNorm * pentatonic.length);
            const semitones = pentatonic[noteIndex] + Math.floor(yNorm * 12);
            
            const freq = baseFreq * Math.pow(2, semitones / 12);
            const pan = (zNorm - 0.5) * 2; // -1 to 1
            
            return { freq, pan };
        }
        
        function playFiberSound(fiberPoints) {
            const duration = 0.4;
            fiberPoints.forEach((point, i) => {
                const { freq, pan } = positionToNote(point);
                playNote(freq, duration, pan, i * 0.15);
            });
        }
        
        // ============ TIMELINE MOMENTS ============
        const collaborationMoments = [
            { t: 0, text: "a blank canvas awaits..." },
            { t: 10, text: "what if notation could perform itself?" },
            { t: 20, text: "‚à´ echo(t)¬∑fade(t) dt" },
            { t: 30, text: "the pieces begin to emerge" },
            { t: 40, text: "f: Human √ó AI ‚Üí Artifact" },
            { t: 50, text: "selfexecuting.art" },
            { t: 60, text: "the paper takes shape" },
            { t: 70, text: "fibers, bundles, topology..." },
            { t: 80, text: "what does collaboration space look like?" },
            { t: 90, text: "this visualization appears" },
            { t: 100, text: "you are here" },
        ];
        
        // ============ THREE.JS SETUP ============
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0f);
        scene.fog = new THREE.FogExp2(0x0a0a0f, 0.012);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(40, 30, 40);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.target.set(0, 5, 0);
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const colors = {
            human: 0xff6699,
            ai: 0x6699ff,
            artifact: 0x66ff99,
            current: 0xffcc66,
            fiber: 0x444466,
            fiberHighlight: 0xff99cc,
            grid: 0x1a1a2a
        };
        
        // Data structures
        const artifacts = [];
        const allFibers = [];
        const artifactFibers = new Map(); // Map artifact -> its fibers
        const humanPoints = [];
        const aiPoints = [];
        let currentPath = null;
        let currentPathPoints = [];
        let showAllFibers = false;
        let selectedArtifact = null;
        let timelineValue = 100;
        
        // ============ GRID ============
        function createGrid() {
            const gridHelper = new THREE.GridHelper(60, 30, colors.grid, colors.grid);
            gridHelper.position.y = -15;
            scene.add(gridHelper);
            
            const axisLength = 35;
            
            const xGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-axisLength, 0, 0),
                new THREE.Vector3(axisLength, 0, 0)
            ]);
            scene.add(new THREE.Line(xGeom, new THREE.LineBasicMaterial({ 
                color: colors.human, transparent: true, opacity: 0.4 
            })));
            
            const yGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -20, 0),
                new THREE.Vector3(0, 30, 0)
            ]);
            scene.add(new THREE.Line(yGeom, new THREE.LineBasicMaterial({ 
                color: colors.artifact, transparent: true, opacity: 0.4 
            })));
            
            const zGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -axisLength),
                new THREE.Vector3(0, 0, axisLength)
            ]);
            scene.add(new THREE.Line(zGeom, new THREE.LineBasicMaterial({ 
                color: colors.ai, transparent: true, opacity: 0.4 
            })));
        }
        
        // ============ ARTIFACT ============
        function createArtifact(x, y, z, name, fiberThickness, description) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: colors.artifact,
                transparent: true,
                opacity: 0.9
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            sphere.userData = { name, fiberThickness, description, type: 'artifact', originalColor: colors.artifact };
            scene.add(sphere);
            artifacts.push(sphere);
            artifactFibers.set(sphere, []);
            
            const glowGeom = new THREE.SphereGeometry(0.8, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: colors.artifact,
                transparent: true,
                opacity: 0.15
            });
            sphere.add(new THREE.Mesh(glowGeom, glowMat));
            
            return sphere;
        }
        
        // ============ FIBER ============
        function createFiber(startPos, artifactPos, artifact, isCurrentPath = false) {
            const midY = (startPos.y + artifactPos.y) / 2 + 5;
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                new THREE.Vector3(
                    (startPos.x + artifactPos.x) / 2,
                    midY,
                    (startPos.z + artifactPos.z) / 2
                ),
                new THREE.Vector3(artifactPos.x, artifactPos.y, artifactPos.z)
            ]);
            
            const points = curve.getPoints(30);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const color = isCurrentPath ? colors.current : colors.fiber;
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: isCurrentPath ? 0.9 : 0.08
            });
            
            const line = new THREE.Line(geometry, material);
            line.userData = { isCurrentPath, artifact, points };
            scene.add(line);
            allFibers.push(line);
            
            if (artifact && artifactFibers.has(artifact)) {
                artifactFibers.get(artifact).push(line);
            }
            
            return { line, points };
        }
        
        // ============ INPUT POINTS ============
        function createInputPoint(x, y, z, type) {
            const geometry = new THREE.SphereGeometry(0.3, 12, 12);
            const color = type === 'human' ? colors.human : colors.ai;
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            scene.add(sphere);
            
            if (type === 'human') humanPoints.push(sphere);
            else aiPoints.push(sphere);
            
            return sphere;
        }
        
        // ============ POPULATE ============
        function populateSpace() {
            const pieces = [
                { name: 'Memory', pos: [8, 10, 5], fiber: 2, desc: '‚à´‚ÇÄ^‚àû echo(t)¬∑fade(t) dt' },
                { name: 'Recursion', pos: [-10, 14, 8], fiber: 3, desc: 'f(n) = f(n-1) + f(n-2)' },
                { name: 'Convergence', pos: [12, 8, -8], fiber: 4, desc: 'lim_{n‚Üí‚àû} a‚Çô = L' },
                { name: 'Collaboration', pos: [0, 20, 0], fiber: 1, desc: 'f: H √ó A ‚Üí ùíú (sparse fiber)' },
                { name: 'Question', pos: [-8, 12, -10], fiber: 5, desc: '‚àÉx : P(x) ?' },
                { name: 'Inverse', pos: [15, 9, 10], fiber: 3, desc: 'f‚Åª¬π(y) = {x : f(x) = y}' },
                { name: 'Self-Reference', pos: [-5, 22, 6], fiber: 1, desc: 'This := perform(This)' },
            ];
            
            pieces.forEach(p => {
                const artifact = createArtifact(p.pos[0], p.pos[1], p.pos[2], p.name, p.fiber, p.desc);
                artifact.scale.set(1.3, 1.3, 1.3);
            });
            
            // Potential artifacts
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 50;
                const y = Math.random() * 20 + 2;
                const z = (Math.random() - 0.5) * 50;
                const fiber = Math.floor(Math.random() * 8) + 2;
                const artifact = createArtifact(x, y, z, `Potential ${i+1}`, fiber, 'An artifact not yet realized');
                artifact.scale.set(0.6, 0.6, 0.6);
                artifact.material.opacity = 0.4;
            }
            
            // Input points
            for (let i = 0; i < 12; i++) {
                createInputPoint((Math.random() - 0.5) * 40, -10 + Math.random() * 3, (Math.random() - 0.5) * 15, 'human');
                createInputPoint((Math.random() - 0.5) * 15, -10 + Math.random() * 3, (Math.random() - 0.5) * 40, 'ai');
            }
            
            // Create fibers for main pieces
            artifacts.slice(0, 7).forEach((artifact) => {
                const numFibers = artifact.userData.fiberThickness || 2;
                for (let i = 0; i < numFibers; i++) {
                    const hIdx = Math.floor(Math.random() * humanPoints.length);
                    const aIdx = Math.floor(Math.random() * aiPoints.length);
                    const inputPos = {
                        x: (humanPoints[hIdx].position.x + aiPoints[aIdx].position.x) / 2,
                        y: -10,
                        z: (humanPoints[hIdx].position.z + aiPoints[aIdx].position.z) / 2
                    };
                    createFiber(inputPos, artifact.position, artifact, false);
                }
            });
            
            // Current collaboration
            const currentHuman = createInputPoint(-8, -8, 3, 'human');
            currentHuman.material.color.setHex(colors.current);
            currentHuman.material.opacity = 1;
            currentHuman.scale.set(1.8, 1.8, 1.8);
            
            const currentAI = createInputPoint(3, -8, -8, 'ai');
            currentAI.material.color.setHex(colors.current);
            currentAI.material.opacity = 1;
            currentAI.scale.set(1.8, 1.8, 1.8);
            
            const collabArtifact = artifacts.find(a => a.userData.name === 'Collaboration');
            if (collabArtifact) {
                collabArtifact.material.color.setHex(colors.current);
                collabArtifact.userData.originalColor = colors.current;
                collabArtifact.scale.set(2, 2, 2);
                
                const inputPos = {
                    x: (currentHuman.position.x + currentAI.position.x) / 2,
                    y: -8,
                    z: (currentHuman.position.z + currentAI.position.z) / 2
                };
                const { line, points } = createFiber(inputPos, collabArtifact.position, collabArtifact, true);
                currentPath = line;
                currentPathPoints = points;
            }
        }
        
        // ============ PARTICLES ============
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = 400;
            const positions = new Float32Array(count * 3);
            
            for (let i = 0; i < count * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = (Math.random() - 0.5) * 60;
                positions[i + 2] = (Math.random() - 0.5) * 100;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x445566,
                size: 0.15,
                transparent: true,
                opacity: 0.4
            });
            
            scene.add(new THREE.Points(geometry, material));
        }
        
        // ============ INVERSE GALLERY (#2) ============
        function highlightArtifactFibers(artifact) {
            // Reset all fibers first
            allFibers.forEach(f => {
                if (!f.userData.isCurrentPath) {
                    f.material.color.setHex(colors.fiber);
                    f.material.opacity = showAllFibers ? 0.25 : 0.08;
                }
            });
            
            // Reset all artifacts
            artifacts.forEach(a => {
                if (a !== artifact && a.userData.originalColor !== colors.current) {
                    a.material.color.setHex(a.userData.originalColor);
                }
            });
            
            if (!artifact) {
                selectedArtifact = null;
                return;
            }
            
            selectedArtifact = artifact;
            
            // Highlight this artifact's fibers
            const fibers = artifactFibers.get(artifact) || [];
            fibers.forEach(f => {
                f.material.color.setHex(colors.fiberHighlight);
                f.material.opacity = 0.8;
            });
        }
        
        // ============ CLICK HANDLING ============
        function onMouseClick(event) {
            if (event.target.closest('.overlay, .info-panel, .controls, .legend, button, a, .timeline')) {
                return;
            }
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(artifacts);
            
            if (intersects.length > 0) {
                const artifact = intersects[0].object;
                showInfoPanel(artifact.userData);
                highlightArtifactFibers(artifact);
                
                // Store for sound button
                window.selectedArtifactFibers = artifactFibers.get(artifact) || [];
            } else {
                hideInfoPanel();
                highlightArtifactFibers(null);
            }
        }
        
        function showInfoPanel(data) {
            document.getElementById('info-title').textContent = data.name;
            document.getElementById('info-desc').textContent = data.description;
            document.getElementById('info-fiber').textContent = `Fiber thickness: ${data.fiberThickness}`;
            
            const fiberDesc = data.fiberThickness === 1 
                ? 'Sparse fiber ‚Äî singular collaboration, unique path'
                : data.fiberThickness <= 3
                ? 'Thin fiber ‚Äî few paths reach this artifact'
                : 'Thick fiber ‚Äî many collaborations converge here';
            document.getElementById('info-fiber-desc').textContent = fiberDesc;
            
            document.getElementById('info-panel').classList.add('visible');
        }
        
        function hideInfoPanel() {
            document.getElementById('info-panel').classList.remove('visible');
        }
        
        // ============ TIMELINE (#1) ============
        function updateTimeline(value) {
            timelineValue = value;
            document.getElementById('time-display').textContent = `moment ${value}`;
            
            // Find appropriate moment text
            let momentText = '';
            for (let i = collaborationMoments.length - 1; i >= 0; i--) {
                if (value >= collaborationMoments[i].t) {
                    momentText = collaborationMoments[i].text;
                    break;
                }
            }
            document.getElementById('timeline-moment').textContent = momentText;
            
            // Animate the current path based on timeline
            if (currentPath && currentPathPoints.length > 0) {
                const visiblePoints = Math.floor((value / 100) * currentPathPoints.length);
                const newPoints = currentPathPoints.slice(0, Math.max(2, visiblePoints));
                const newGeom = new THREE.BufferGeometry().setFromPoints(newPoints);
                currentPath.geometry.dispose();
                currentPath.geometry = newGeom;
            }
            
            // Fade artifacts based on timeline
            const collabArtifact = artifacts.find(a => a.userData.name === 'Collaboration');
            if (collabArtifact) {
                collabArtifact.material.opacity = value / 100;
                const scale = 1 + (value / 100);
                collabArtifact.scale.set(scale, scale, scale);
            }
        }
        
        // ============ EVENT HANDLERS ============
        document.getElementById('close-info').addEventListener('click', () => {
            hideInfoPanel();
            highlightArtifactFibers(null);
        });
        
        document.getElementById('btn-rotate').addEventListener('click', function() {
            controls.autoRotate = !controls.autoRotate;
            this.classList.toggle('active');
        });
        
        document.getElementById('btn-fibers').addEventListener('click', function() {
            showAllFibers = !showAllFibers;
            this.classList.toggle('active');
            
            allFibers.forEach(f => {
                if (!f.userData.isCurrentPath) {
                    f.material.opacity = showAllFibers ? 0.25 : 0.08;
                }
            });
        });
        
        document.getElementById('btn-sound').addEventListener('click', function() {
            if (currentPathPoints.length > 0) {
                playFiberSound(currentPathPoints);
            }
        });
        
        document.getElementById('play-fiber-sound').addEventListener('click', function() {
            const fibers = window.selectedArtifactFibers || [];
            if (fibers.length > 0 && fibers[0].userData.points) {
                playFiberSound(fibers[0].userData.points);
            }
        });
        
        document.getElementById('btn-reset').addEventListener('click', function() {
            camera.position.set(40, 30, 40);
            controls.target.set(0, 5, 0);
            controls.autoRotate = true;
            document.getElementById('btn-rotate').classList.add('active');
            highlightArtifactFibers(null);
            hideInfoPanel();
            document.getElementById('timeline-slider').value = 100;
            updateTimeline(100);
        });
        
        document.getElementById('btn-reset-sim').addEventListener('click', function() {
            // Randomize all human point positions
            humanPoints.forEach(p => {
                p.position.set(
                    (Math.random() - 0.5) * 40,
                    -10 + Math.random() * 3,
                    (Math.random() - 0.5) * 15
                );
            });
            
            // Randomize all AI point positions
            aiPoints.forEach(p => {
                p.position.set(
                    (Math.random() - 0.5) * 15,
                    -10 + Math.random() * 3,
                    (Math.random() - 0.5) * 40
                );
            });
            
            // Randomize potential artifact positions
            artifacts.forEach(a => {
                if (a.userData.name && a.userData.name.startsWith('Potential')) {
                    a.position.set(
                        (Math.random() - 0.5) * 50,
                        Math.random() * 20 + 2,
                        (Math.random() - 0.5) * 50
                    );
                }
            });
        });
        
        document.getElementById('timeline-slider').addEventListener('input', function() {
            updateTimeline(parseInt(this.value));
        });
        
        // ============ MAPPING SLIDERS ============
        function updateMappingSlider(type, value) {
            const pct = value / 100;
            
            switch(type) {
                case 'human':
                    humanPoints.forEach(p => {
                        p.material.opacity = 0.7 * pct;
                        const s = 0.3 + pct * 0.7;
                        p.scale.set(s, s, s);
                    });
                    break;
                    
                case 'ai':
                    aiPoints.forEach(p => {
                        p.material.opacity = 0.7 * pct;
                        const s = 0.3 + pct * 0.7;
                        p.scale.set(s, s, s);
                    });
                    break;
                    
                case 'artifact':
                    artifacts.forEach(a => {
                        const baseOpacity = a.userData.name.startsWith('Potential') ? 0.4 : 0.9;
                        a.material.opacity = baseOpacity * pct;
                        // Don't scale the special ones too much
                        if (a.userData.originalColor !== colors.current) {
                            const baseScale = a.userData.name.startsWith('Potential') ? 0.6 : 1.3;
                            const s = baseScale * (0.3 + pct * 0.7);
                            a.scale.set(s, s, s);
                        }
                    });
                    break;
                    
                case 'fiber':
                    allFibers.forEach(f => {
                        if (f.userData.isCurrentPath) {
                            f.material.opacity = 0.9 * pct;
                        } else {
                            const baseOpacity = showAllFibers ? 0.25 : 0.08;
                            f.material.opacity = baseOpacity * pct;
                        }
                    });
                    break;
            }
        }
        
        ['human', 'ai', 'artifact', 'fiber'].forEach(type => {
            const slider = document.getElementById(`slider-${type}`);
            const display = document.getElementById(`val-${type}`);
            
            slider.addEventListener('input', function() {
                const val = parseInt(this.value);
                display.textContent = `${val}%`;
                updateMappingSlider(type, val);
            });
        });
        
        // ============ COUNT SLIDERS ============
        function setPointCount(type, count) {
            const points = type === 'human' ? humanPoints : aiPoints;
            const color = type === 'human' ? colors.human : colors.ai;
            
            // Remove excess points
            while (points.length > count) {
                const p = points.pop();
                scene.remove(p);
            }
            
            // Add new points if needed
            while (points.length < count) {
                const geometry = new THREE.SphereGeometry(0.3, 12, 12);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const sphere = new THREE.Mesh(geometry, material);
                
                if (type === 'human') {
                    sphere.position.set(
                        (Math.random() - 0.5) * 40,
                        -10 + Math.random() * 3,
                        (Math.random() - 0.5) * 15
                    );
                } else {
                    sphere.position.set(
                        (Math.random() - 0.5) * 15,
                        -10 + Math.random() * 3,
                        (Math.random() - 0.5) * 40
                    );
                }
                
                scene.add(sphere);
                points.push(sphere);
            }
        }
        
        ['human', 'ai'].forEach(type => {
            const slider = document.getElementById(`count-${type}`);
            const display = document.getElementById(`count-val-${type}`);
            
            slider.addEventListener('input', function() {
                const val = parseInt(this.value);
                display.textContent = val;
                setPointCount(type, val);
            });
        });
        
        // ============ ANIMATION ============
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            const time = Date.now() * 0.001;
            const collabArtifact = artifacts.find(a => a.userData.name === 'Collaboration');
            if (collabArtifact && timelineValue === 100) {
                const baseScale = 2;
                const scale = baseScale + Math.sin(time * 2) * 0.15;
                collabArtifact.scale.set(scale, scale, scale);
            }
            
            if (currentPath && timelineValue === 100) {
                currentPath.material.opacity = 0.7 + Math.sin(time * 3) * 0.25;
            }
            
            renderer.render(scene, camera);
        }
        
        // ============ RESIZE ============
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        window.addEventListener('click', onMouseClick);
        
        // ============ INIT ============
        createGrid();
        createParticles();
        populateSpace();
        animate();
        updateTimeline(100);
        
        console.log('Collaboration Space v4 loaded ‚Äî with intensity sliders, quantity sliders, sound, inverse gallery, and timeline');
    </script>
</body>
</html>
